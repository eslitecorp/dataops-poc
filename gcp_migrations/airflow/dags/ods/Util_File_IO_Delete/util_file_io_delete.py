from __future__ import annotations
from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.utils.session import provide_session
from datetime import datetime
import os, glob, shutil, logging
from typing import List

DAG_ID = "util_file_io_delete"
DEFAULT_FILES_PARAM = r"C:\data\a.csv;C:\data\b.csv"

def _generate_src_file_path_list(**context) -> None:
    """Parse the semicolon-separated file path string into a list.

    This task reads the `sourceFilePath` parameter from Airflow `params`,
    splits it by semicolons (`;`), trims spaces, and stores the resulting
    list of paths into XCom for downstream tasks.

    Example:
        sourceFilePath = "C:\\data\\a.csv;C:\\data\\b.csv"
        → XCom key `srcFilePathList` = ["C:\\data\\a.csv", "C:\\data\\b.csv"]

    Args:
        **context: Airflow context containing:
            - params["sourceFilePath"]: The input path string.
            - ti: TaskInstance, used to push to XCom.

    Returns:
        None
    """
    src = context["params"].get("sourceFilePath", "") or ""
    paths: List[str] = [p.strip() for p in src.split(";") if p.strip()]
    logging.info("Parsed %d path(s): %s", len(paths), paths)
    context["ti"].xcom_push(key="srcFilePathList", value=paths)

def _clean_old_files(**context) -> dict:
    """Delete files or folders listed in XCom.

    This task pulls the list of paths generated by `_generate_src_file_path_list`
    and deletes them:
      - If path is a file → directly removed.
      - If path is a folder → all its contents are removed, but the folder itself remains.
      - Wildcards (*, ?) are supported via `glob.glob()`.

    Args:
        **context: Airflow context containing:
            - ti: TaskInstance, used to pull `srcFilePathList` from XCom.

    Returns:
        None
    """
    ti = context["ti"]
    paths: List[str] = ti.xcom_pull(task_ids="parse_source_file_paths", key="srcFilePathList") or []
    if not paths:
        logging.info("No paths to clean. Skipping.")
        return

    deleted = 0
    for p in paths:
        expanded = glob.glob(p) or [p]
        for q in expanded:
            if os.path.isfile(q) or os.path.islink(q):
                os.remove(q)
                deleted += 1
                logging.info("Deleted file: %s", q)
            elif os.path.isdir(q):
                # 清空資料夾內容，不刪資料夾本身
                for name in os.listdir(q):
                    target = os.path.join(q, name)
                    if os.path.isfile(target) or os.path.islink(target):
                        os.remove(target)
                        deleted += 1
                        logging.info("Deleted file: %s", target)
                    else:
                        shutil.rmtree(target)
                        deleted += 1
                        logging.info("Deleted dir: %s", target)
            else:
                logging.info("Not found or unsupported path, skip: %s", q)

    logging.info("Clean finished. Deleted=%d", deleted)




with DAG(
    dag_id=DAG_ID,
    start_date=datetime(2025, 1, 1),
    schedule=None,
    catchup=False,
    params={"sourceFilePath": DEFAULT_FILES_PARAM}, 
    tags=["io", "cleanup"],
) as dag:

    parse_task = PythonOperator(
        task_id="parse_source_file_paths",
        python_callable=_generate_src_file_path_list,
    )

    clean_files = PythonOperator(
        task_id="clean_old_files",
        python_callable=_clean_old_files,
    )

    parse_task >> clean_files